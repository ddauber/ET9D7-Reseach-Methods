[["r-basics-the-very-fundamentals.html", "5 R Basics: The very fundamentals 5.1 Basic computations in R 5.2 Assigning values to objects: ‘&lt;-’ 5.3 Functions 5.4 R packages 5.5 Exercises", " 5 R Basics: The very fundamentals After a likely tedious installation of R and RStudio, as well as a somewhat detailed introduction to the RStudio interface, you are finally ready to ‘do’ things. By ‘doing,’ I mean coding. The term ‘coding’ in itself can instil fear in some of you, but you only need one skill to do it: Writing. As mentioned earlier, learning coding or programming means learning a new language. However, once you have the basic grammar down, you already can communicate quite a bit. In this section, we will explore the fundamentals of R. These build the foundation for everything that follows. After that, we dive right into some analysis. 5.1 Basic computations in R The most basic computation you can do in R is arithmetic operations. In other words, addition, subtraction, multiplication, division, exponentiation and extraction of roots. In other words, R can be used like your pocket calculator, or more likely the one you have on your phone. For example, in Chapter 4.1 we already performed an addition. Thus, it might not come as a surprise how their equivalents work in R. Let’s take a look at the following examples: # Addition 10+5 ## [1] 15 # Subtraction 10-5 ## [1] 5 # Multiplication 10*5 ## [1] 50 # Division 10/5 ## [1] 2 # Exponentiation 10^2 ## [1] 100 # Square root sqrt(10) ## [1] 3.162278 They all look fairly straightforward except for the extraction of roots. As you probably know, extracting the root would typically mean we use the symbol \\(\\sqrt{}\\) on your calculator. To compute the square root in R, we have to use a function instead to perform the computation. So we first put the name of the function sqrt and then the value 10 within parenthesis (). This results in the following code: sqrt(10). If we were to write this down in our report, we would write \\(\\sqrt[2]{10}\\). Functions are an essential part of R and programming in general. You will learn more about them in this chapter.Besides arithmetic operations, there are also logical queries you can perform. Logical queries always return either the value TRUE or FALSE. Here are some examples which make this clearer: #1 Is it TRUE or FALSE? 1 == 1 ## [1] TRUE #2 Is 45 bigger than 55? 45 &gt; 55 ## [1] FALSE #3 Is 1982 bigger or equal to 1982? 1982 &gt;= 1982 ## [1] TRUE #4 Are these two words NOT the same? &quot;Friends&quot; != &quot;friends&quot; ## [1] TRUE #5 Are these sentences the same? &quot;I love statistics&quot; == &quot;I love statistícs&quot; ## [1] FALSE Reflecting on these examples, you might notice three important things: I used == instead of =, I can compare non-numerical values, i.e. text, which is also known as character values, with each other, The devil is in the details considering #5. One of the most common mistakes of R novices is the confusion around the == and = notation. While == represents equal to, = is used to assign a value to an object (for more details on assignments see Chapter 4.4). However, in practice, most R programmers tend to avoid = since it can easily lead to confusion with ==. As such, you can strike this one out of your R vocabulary for now. There are many different logical operations you can perform. Table 5.1 lists the most frequently used logical operators for your reference. These will become important once we select only certain parts of our data for analysis, e.g. only female participants. Table 5.1: Logical Operators in R Operator Description == is equal to &gt;= is bigger or equal to &lt;= is smaller of equal to != is not equal to a | b a or b a &amp; b a and b !a is not a 5.2 Assigning values to objects: ‘&lt;-’ Another common task you will perform is assigning values to an object. An object can be many different things: a dataset, the results of a computation, a plot, a series of numbers, a list of names, a function, etc. In short, an object is an umbrella term for many different things which form part of your data analysis. For example, objects are handy when storing results that you want to process further in later analytical steps. Let’s have a look at an example. # I have a friend called &quot;Fiona&quot; friends &lt;- &quot;Fiona&quot; In this example, I created an object called friends and added \"Fiona\" to it. Remember, because \"Fiona\" represents a string, we need \"\". So, if you wanted to read this line of code, you would say, ‘friends gets the value \"Fiona\".’ Alternatively, you could also say ‘\"Fiona\" is assigned to friends.’ If you look into your environment pane, you will find the object we just created. You can see it carries the value \"Fiona\". We can also print values of an object in the console by simply typing the name of the object friends and hit Return ↵. # Who are my friends? friends ## [1] &quot;Fiona&quot; Sadly, it seems I only have one friend. Luckily we can add some more, not the least to make me feel less lonely. To create objects with multiple values, we can use the function c(), which stands for ‘concatenate.’ The Cambridge Dictionary (2021) define this word as follows: ‘concatenate,’ to put things together as a connected series Let’s concatenate some more friends into our friends object. # Adding some more friends to my life friends &lt;- c(&quot;Fiona&quot;, &quot;Ida&quot;, &quot;Lukas&quot;, &quot;Georg&quot;, &quot;Daniel&quot;, &quot;Pavel&quot;, &quot;Tigger&quot;) # Here are all my friends friends ## [1] &quot;Fiona&quot; &quot;Ida&quot; &quot;Lukas&quot; &quot;Georg&quot; &quot;Daniel&quot; &quot;Pavel&quot; &quot;Tigger&quot; To concatenate values into a single object, we need to use a comma , to separate each value. Otherwise, R will report an error back. friends &lt;- c(&quot;Fiona&quot; &quot;Ida&quot;) ## Error: &lt;text&gt;:1:22: unexpected string constant ## 1: friends &lt;- c(&quot;Fiona&quot; &quot;Ida&quot; ## ^ R’s error messages tend to be very useful and give meaningful clues to what went wrong. In this case, we can see that something ‘unexpected’ happen, and it shows where our mistake is. You can also concatenate numbers, and if you add () around it, you can automatically print the content of the object to the console. Thus, (milestones_of_my_life &lt;- c(1982, 2006, 2011, 2018, 2020)) is the same as milestones_of_my_life &lt;- c(1982, 2006, 2011, 2018, 2020) followed by milestones_of_my_life. The following examples illustrate this. # Important years in my life milestones_of_my_life &lt;- c(1982, 2006, 2011, 2018, 2020) milestones_of_my_life ## [1] 1982 2006 2011 2018 2020 # The same as above, but we don&#39;t need the second line of code (milestones_of_my_life &lt;- c(1982, 2006, 2011, 2018, 2020)) ## [1] 1982 2006 2011 2018 2020 Finally, we can also concatenate numbers and character values into one object: (names_and_years &lt;- c(&quot;Fiona&quot;, 1988, &quot;Daniel&quot;, 1982)) ## [1] &quot;Fiona&quot; &quot;1988&quot; &quot;Daniel&quot; &quot;1982&quot; This last example is not necessarily something I would recommend to do, because it likely leads to undesirable outcomes. If you look into your environment pane you currently have three objects: friends, milestones_of_my_life, and names_and_years. The friends object shows that all the values inside the object are classified as chr, which denominates character. In this case, this is correct because it only includes the names of my friends. On the other hand, the object milestones_of_my_life only includes numeric values, and therefore it says num in the environment pane. However, for the object names_and_years we know we want to have numeric and character values included. Still, R recognises them as character values only because values inside objects are meant to be of the same type. Consequently, mixing different types of data (as explained in Chapter @ref()) into one object is likely a bad idea. This is especially true if you want to use the numeric values for computation. In short: ensure your objects are all of the same data type. There is an exception to this rule. ‘Of course,’ you might say. There is one object that can have values of different types: list. As the name indicates, a list object holds several items. These items are usually other objects. In the spirit of ‘Inception,’ you can have lists inside lists, which contain more objects. Let’s create a list called x_files using the list function and place all our objects inside. # This creates our list of objects x_files &lt;- list(friends, milestones_of_my_life, names_and_years) # Let&#39;s have a look what is hidden inside the x_files x_files ## [[1]] ## [1] &quot;Fiona&quot; &quot;Ida&quot; &quot;Lukas&quot; &quot;Georg&quot; &quot;Daniel&quot; &quot;Pavel&quot; &quot;Tigger&quot; ## ## [[2]] ## [1] 1982 2006 2011 2018 2020 ## ## [[3]] ## [1] &quot;Fiona&quot; &quot;1988&quot; &quot;Daniel&quot; &quot;1982&quot; You will notice in this example that I do not use \"\" for each value in the list. This is because friends is not a character I put into the list, but an object. When we refer to objects we do not need the quotation marks. We will encounter list objects quite frequently when we perform our analysis. Some functions return the results in the format of lists. This can be very helpful, because otherwise our environment pane will be littered with objects, but we would not necessarily know how they relate to each other or worse, to which analysis they belong. Looking at the list item in the environment page (Figure 5.1), you can see that the object x_files is classified as a List of 3 and if you click on the blue icon, you can inspect the different objects inside. Figure 5.1: The environment pane showing our objects and our list 'x_files' In Chapter 5.1 I mentioned that we should avoid using the = operator and explained that it is used to assign values to objects. You can, if you want, use = instead of &lt;-. They fulfil the same purpose. However, as mentioned before, it is not wise to do so. Here is an example that shows that, in principle, it is possible. # DO (avengers1 &lt;- c(&quot;Iron Man&quot;, &quot;Captain America&quot;, &quot;Black Widow&quot;, &quot;Vision&quot;)) ## [1] &quot;Iron Man&quot; &quot;Captain America&quot; &quot;Black Widow&quot; &quot;Vision&quot; # DON&#39;T (avengers2 = c(&quot;Iron Man&quot;, &quot;Captain America&quot;, &quot;Black Widow&quot;, &quot;Vision&quot;)) ## [1] &quot;Iron Man&quot; &quot;Captain America&quot; &quot;Black Widow&quot; &quot;Vision&quot; On a final note, naming your objects is limited. Not every name can be chosen. First, every name needs to start with a letter. You also can only use letters, numbers _ and . as valid components of the names of your objects (see also Wickham and Grolemund 2016, Chapter 4.2.). 5.3 Functions I used the term ‘function’ multiple times already, but I never really fully explained what they are and why we need them. In very simple terms, functions are objects. They contain lines of code that someone has written for us (ro we have written ourselves). One could say they are code snippets ready to use. Someone else might see them as shortcuts for our programming. Functions not only increase the speed with which we perform our analysis and write our computations, but also make our code more readable. Consider computing the mean of values stored in the object pocket_money. # First we create an object that stores our desired values pocket_money &lt;- c(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89) #1 Manually compute the mean: sum &lt;- 0+1+1+2+3+5+8+13+21+34+55+89 sum/12 # There are 12 items in the object ## [1] 19.33333 #2 Use a function to compute the mean: mean(pocket_money) ## [1] 19.33333 #3 Let&#39;s make sure it is actually the same sum/12 == mean(pocket_money) ## [1] TRUE If we manually compute the mean, we first compute the sum of all values in the object pocket_money1, and then we divide it by the number of values in the object, which is 12. This is the classic way of computing the mean as we know it. However, my simply using the function mean(), we not only write considerably less code, it is much easer to understand as well, because the word mean does exactly what we would expect. Which one do you find easier? All functions in R share the same structure. They have a name follow by () and within these parentheses we put arguments, which have certain values. A function would look something like this: name_of_function(argument_1 = value_1, argument_2 = value_2, argument_3 = value_3) How many arguments there are and what kind of values you can provide is very much dependent on the function you use. Thus, not every function takes every value. It is fair to make the analogy that function names are similar to vocabulary of a foreign language, while the arguments represent a specific syntax that goes with it. In the case of mean(), the function takes an object which holds a sequence of numeric values. It would make very little sense to compute the mean of our friends object, because it only contains names. R would return an error message: mean(friends) ## Warning in mean.default(friends): argument is not numeric or logical: returning ## NA ## [1] NA NA refers to a value that is ‘not available’. In this case, R tries to compute the mean but the result is not available. However, it can run the function mean(). Therefore, this value is NA. In your dataset, you might find cells that are NA, which means there is data missing. You will learn more about how to deal with this in Chapter @ref(). Sometimes you will also get a message from R that something is NaN. This stands for ‘not a number’ and is returned when something is not possible to compute, for example: # Example 1 0/0 ## [1] NaN # Example 2 sqrt(-9) ## Warning in sqrt(-9): NaNs produced ## [1] NaN 5.4 R packages R has many built-in functions that we can use right away. However, some of the most interesting ones are actually developed by different programmers, data scientists and enthusiasts. To add more functions to your repertoire, you can install R packages. R packages are a collection of functions that you can download and use for your own analysis. Throughout this book you will learn about and use many different R packages to accomplish different tasks. To give you another analogy, R is like a global supermarket, RStudio is like my shopping cart, and R packages are the products I can pick from the shelves. Luckily, R packages are free to use, so I do not have to bring my credit card. For me, these additional functions, developed by some of the greatest scientists, is what keeps me addicted to performing my research in R. R packages do not only include functions, but often include datasets and documentation of what each function does. This way you can easily try every function right away even without your own dataset and read through what each function in the package does. Figure 5.2 Figure 5.2: The R package documentation for ‘ggplot2’ However, how do you find those R packages? They are right at your fingertips. You have two options: Use the Packages pane (see Chapter 4.4) Or call the function install.packages() 5.4.1 Installing packages via RStudio’s Package pane to be added 5.4.2 Installing packages using install.packages() The simplest and fastest way to install a package is calling the function install.packages(). You can either use it to install a single package or install a series of packages all at once using our trusty c() function. All you need to know is the name of the package. This approach works for all packages that are on CRAN. # Install a single package install.packages(&quot;tidyverse&quot;) # Installe multiple packages at once install.packages(c(&quot;tidyverse&quot;, &quot;naniar&quot;, &quot;psych&quot;)) If a package is not available from CRAN but from another source, you can provide the URL or file path to where the package is located. However, if you don’t know the developer, it might be wise to hold off using the package. Many R packages are found on GitHub, probably the world’s largest global platform for programmers of all walks of life. # Install a package from another URL install.packages(&quot;https://github.com/tidyverse/forcats.git&quot;) # Installe a package from a file on your computer install.packages(c(&quot;tidyverse&quot;, &quot;naniar&quot;, &quot;psych&quot;)) # Install the &#39;wesanderson&#39; package from GitHub devtools::install_github(&quot;karthik/wesanderson&quot;) 5.4.3 Using R Packages Now that you have a nice collection of R Packages the next step would be to use them. While you only have to install R packages once, you have to ‘activate’ them. This is also called ‘loading an R package.’ Once an R package is loaded you can use all its functions. To load an R package we have to use the function library(). library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ── ## ✓ ggplot2 3.3.5 ✓ purrr 0.3.4 ## ✓ tibble 3.1.2 ✓ dplyr 1.0.7 ## ✓ tidyr 1.1.3 ✓ stringr 1.4.0 ## ✓ readr 2.0.0 ✓ forcats 0.5.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() The tidyverse package is a special kind of package. It contains multiple packages and loads them all at once. Almost all of these packages you will use at some point when working through this book. I know what you are thinking. Can you use c() to load all your packages at once? Unfortunately not. However, there is a way to do this, but it goes beyond the scope of this book to fully explain this (if you are curious you can take a peak here). Besides, it is not always advisable to load all functions of an entire package. One reason could be that two packages contain a function with the same name, but with a different purpose. This would create a conflict between these two packages and one of the functions would not be usable in this way. Another reason could be that you only need to use the function once and loading the whole package to use only one specific function seems excessive. Instead you can explicitly call functions from packages without loading the package. For example we might want to use the vismis() function from the naniar package to show were data is missing in our dataset airquality. In terms of writing the code, this is also much quicker than loading the package and then call the function. # Here I use the dataset called &#39;airquality&#39;, which comes with R naniar::vis_miss(airquality) 5.5 Exercises What is the result of \\(\\sqrt[2]{25-16}+2*8-6\\)? What does the console return if you execute the following code \"Five\" == 5? Create a list called books and include the folKlowing book titles in it: “Harry Potter and the Deathly Hallows,” “The Alchemist,” “The Davinci Code,” “R For Dummies” Check you answers: 6.1 References "]]
