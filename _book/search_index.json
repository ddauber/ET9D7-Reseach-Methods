[["data-wrangling.html", "7 Data Wrangling 7.1 Import your data 7.2 Inspecting your data 7.3 Cleaning your column names: Call the janitor 7.4 Data types: What are they and how can you change them 7.5 Recoding factors (e.g. gender coded as 0 and 1) 7.6 Dealing with missing data 7.7 Latent constructs and their reliability", " 7 Data Wrangling You collected your data over months (and sometimes years) and all you really want to know is whether your data makes sense and reveals something nobody would have ever expected. However, before we can truly go ahead with our analysis, it is essential to understand whether our data is ‘tidy.’ Very often, data we receive is everything else but clean and we need to not only check whether our data is fit for analysis, but also ensure it is in a format that is easy to handle and work with. For small datasets, this is usually a brief exercise. However, I found myself cleaning data for a month, because the dataset was spread out into multiple spreadsheets (no pun intended) with different numbers of columns and odd column names. Thus, data cleaning or data wrangling is an essential first step in any data analysis. It is a step that cannot be skipped and has to be performed on every new dataset. Luckily, R provides many useful functions to make our lives easier. If you are like me and used to do this in Excel, you will be in for a treat. It is a lot simpler using R to do achieve a clean dataset. Here is an overview of the different steps we usually work through before we can start with our main analysis. This is list is certainly not exhaustive: Data import Checking data types Recoding and arranging factors, i.e. categorical data. Running missing data diagnostics and other things 7.1 Import your data The r4np package hosts a number of different datasets to work with, but at some point you might want to apply your R knowledge to your own data. Therefore, an important first step is to import your data into RStudio. There are three different methods all of which are very handy: Click on your data file in the Files pane and choose `Import Dataset’. Use the Import Dataset button in the Environment pane. Import your data calling one of the readr functions in the console or RScript We will use the readr package to import our data. Using this package we can import a range of different file formats, including .csv, .tsv, .txt. If you want to import data from an .xlsx file you have to use another package called readxl. The following sections will primarily focus on how to use reader via RStudio or directly in your Console or RScript. 7.1.1 Import data from the Files pane This approach is by far the easiest. Let’s assume you have a dataset called gender_age.csv in your 00_raw_data folder. If you wish to import it, you can do the following: Click on the name of the file Select Import Dataset. A new window will open and you can choose different options. You also see a little preview of how the data looks like. This is great if you are not sure whether you did it correctly. You can make changes to how the data should be imported, but in most cases the default should be fine. Here is quick breakdown of the most important options: Name allows you to change the object name, i.e. the name of the object this data will be assigned to. I tend to use df_raw (df stand for dataframe, which is how R calls such rectangular datasets). Skip is useful if your data file starts with a number of empty rows at the top. You can remove them here. First Row as Names is ticked by default. In most Social Science projects we tend to have the name of the variables as the first row in your dataset. Trim Spaces removes any unnecassry white-space in your dataset. Leave it ticked. Open Data Viewer allows you to look at your imported dataset. I use it rarely, but it can be helpful at times. Delimiter defines how your columns are separate from each other in your file. If it is a .csv it would imply it is a ‘comma-separated value,’ i.e. ,. This can be changed for different files, depending on how your data is delimited. You can even use the option Other… to specify a custom separation option. NA specifies how missing values in your data are acknowledged. By default, empty cells in your data will be recognised as missing data. Once you are happy with your choices, you can click on Import. You will find your dataset in the Environment pane. In the console you can see that R also provides the Column specification, which we need later when inspecting ‘data types.’ readr automatically imports all text-based columns as chr, i.e. character values. However, this might not be always true. More on this aspect of data wrangling in Chapter 7.4. 7.1.2 Importing data from the Environment pane The process of important datasets from the Environment pane follows largely the one from the Files pane. Click on Import Dataset &gt; From Text (readr)…. The only main difference lies in having to find the file using the Browse… button. The rest of the steps are the same as above. You will have to use the Environment pane for importing data from specific file types, e.g. .txt, because using the File pane would only open the file, but not import the data for further processing. 7.1.3 Importing data using functions directly If you organised your files well it can be very easy and quick to just use all the functions from readr directly. Here are two examples of how you can use readr to import your data. Make sure you have the tidyverse package loaded. # Import data from &#39;.csv&#39; read_csv(&quot;00_raw_data/gender_age.csv&quot;) # Import data from any file text file by defining the separator yourself read_delim(&quot;00_raw_data/gender_age.txt&quot;, delim = &quot;|&quot;) You might be wondering, whether you can use read_delim() to import .csv files too. The answer is ‘Yes, you can!’ In contrast to read_delim(), read_csv() sets the delimiter to , by default. This is mainly for convenience, because .csv files are one of the most popular file formats that people use for storing their data. You might be also wondering what actually a ‘delimiter’ is. When you record data in a plain-text file it is easy to see where a new observation starts and ends, because it is defined by a row in your file. However, we also need to tell our software where a new column starts, i.e. where a cell starts and ends. Consider the following example. We have a file that holds our data which looks like this: idagegender 124male 256female 333male The first row we probably can still decipher as id, age, gender. However, the next row makes it difficult to understand which value represents the id of a participant and which value reflects the age of that participant. Like us, computer software would find it hard too to make a decision regarding this ambiguous content. Thus, we need to use delimiters to make it very clear which value belongs to which column. In a .csv file the data would be separated by a ,. id,age,gender 1,24,male 2,56,female 3,33,male Considering our example from above, we could also use | as a delimiter. id|age|gender 1|24|male 2|56|female 3|33|male There is a lot more to readr than could be covered in this book. If you want to know more about this R package, I highly recommend to look at the readr webpage. 7.2 Inspecting your data For the rest of this chapter, we will use the wvs dataset from the r4np package. However, we do not know much about this dataset and therefore we cannot ask any research questions worth investigating. Therefore we need to look at what it contains. The first method of inspecting a dataset is to type the name of the object, i.e. wvs. # Ensure you loaded the &#39;r4np&#39; package first library(r4np) # Show the data in the console wvs ## # A tibble: 69,578 × 9 ## `Participant ID` `Country Code` `Country name` Gender YearOfBirth Age ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20070001 AND Andorra 1 1958 60 ## 2 20070002 AND Andorra 0 1971 47 ## 3 20070003 AND Andorra 0 1969 48 ## 4 20070004 AND Andorra 1 1956 62 ## 5 20070005 AND Andorra 0 1969 49 ## 6 20070006 AND Andorra 1 1967 51 ## 7 20070007 AND Andorra 1 1985 33 ## 8 20070008 AND Andorra 0 1963 55 ## 9 20070009 AND Andorra 1 1978 40 ## 10 20070010 AND Andorra 1 1979 38 ## # … with 69,568 more rows, and 3 more variables: relationship_status &lt;chr&gt;, ## # Freedom.of.Choice &lt;dbl&gt;, Satisfaction-with-life &lt;dbl&gt; The result is a series of rows and columns. The first information we receive is: A tibble: 69,578 x 9. This indicates that our dataset has 69,578 observations (i.e. rows) and 9 columns (i.e. variables). This rectangular format is the one we encounter most frequently in Social Sciences (and probably beyond). If you ever worked in Microsoft Excel, this format will look familiar. Even though it might be nice to look at a dataset in this way, it is not particularly useful. Depending on your monitor size you might only see a small number of columns and therefore we do not get to see a complete list of all variables. In short, we hardly ever will find much use in inspecting data this way. Luckily there are other functions that can help us. If you want to see each variable covered in the dataset and their data types, you can use the function glimpse() from the dplyr package (which is loaded when load the tidyverse package). glimpse(wvs) ## Rows: 69,578 ## Columns: 9 ## $ `Participant ID` &lt;dbl&gt; 20070001, 20070002, 20070003, 20070004, 20070… ## $ `Country Code` &lt;chr&gt; &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;, &quot;AN… ## $ `Country name` &lt;chr&gt; &quot;Andorra&quot;, &quot;Andorra&quot;, &quot;Andorra&quot;, &quot;Andorra&quot;, &quot;… ## $ Gender &lt;dbl&gt; 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, … ## $ YearOfBirth &lt;dbl&gt; 1958, 1971, 1969, 1956, 1969, 1967, 1985, 196… ## $ Age &lt;dbl&gt; 60, 47, 48, 62, 49, 51, 33, 55, 40, 38, 54, 3… ## $ relationship_status &lt;chr&gt; &quot;married&quot;, &quot;living together as married&quot;, &quot;sep… ## $ Freedom.of.Choice &lt;dbl&gt; 10, 9, 9, 9, 8, 10, 10, 8, 8, 10, 9, 8, 10, 7… ## $ `Satisfaction-with-life` &lt;dbl&gt; 10, 9, 9, 8, 7, 10, 5, 8, 8, 10, 8, 8, 10, 7,… The output of glimpse shows us the name of each column/variable after the $, for example `Participant ID`. The $ is used to look up certain variables in our dataset. If we want to inspect the column relationship_status only, we could write the following: wvs$relationship_status ## [1] &quot;married&quot; &quot;living together as married&quot; ## [3] &quot;separated&quot; &quot;living together as married&quot; ## [5] &quot;living together as married&quot; &quot;married&quot; ## [7] &quot;married&quot; &quot;widowed&quot; .... After the variable name we find the recognised datatype for each column in &lt;...&gt;, for example &lt;chr&gt;. We will return to data types in Chapter 7.4. Lastly, we get examples of the data that is included. This output is much more helpful. I use glimpse() very frequently for different purposes, for example: to understand what variables are included in a dataset, to check correctness of data types, to inspect variable names for typos or unconventional names, to look up variable names. There is one more way to inspect your data and receive a lot more information about it by using a specialised R package. The skimr package is excellent in ‘skimming’ your dataset. It provides not only information about variable names and data types, but also provides some descriptive statistics. If you installed the r4np package and called the function install_r4np(), you will have skimr installed already. skimr::skim(wvs) The output in the console should look like this: As you can tell, there is a lot more information in this output. Many descriptive statistics that could be useful are already displayed. skim() provides a summary of the dataset first and then sorts the variables automatically by data type. Depending on the data type you also receive different descriptive statistics. As an added bonus, the function also provides a histogram for numeric variables. However, there is one main problem: Some of the numeric variables are actually not numeric: Participant ID and Gender. Thus, we will have to correct the data types in a moment. Inspecting your data in this way can be helpful to get a better understanding of what your data includes and spot problems with it. If you receive data from someone else, these methods are a good way to familiarise yourself with the dataset relatively quickly. Since this particular dataset was prepared for this book, I also made sure I provide documentation for it. You can access it by using ?wvs in the Console. This will open the documentation in the Help pane. Such documentation can be found for every dataset we use in this book. 7.3 Cleaning your column names: Call the janitor If you have an eagle eye, you might have noticed that most of the variable names in wvs are not consistent or easy to read/use. # Whitespace and inconsistent capitalisation Participant ID Country Code Country name Gender Age # Difficult to read YearOfBirth Freedom.of.Choice Satisfaction-with-life From Chapter 5.5, you will remember that being consistent in the way your write your code and name your objects is essential. The same applies, of course, to variable names. R will not break using the existing names, but it will save you a lot of frustration if we take a minute to clean the names and make them more consistent. You are probably thinking: This is easy, I just open the dataset in Excel and change all the column names. Indeed, it would be a viable and easy option, but it is not very efficient, especially with larger datasets that have many more variables. Instead, we can make use of the janitor package. By definition, janitor is a package that helps to clean up whatever needs cleaning. In our case we want to tidy our column names. We can use the function clean_names() to achieve this. We store the result in a new object called wvs to keep those changes. The object will also show up in our Environment pane. wvs &lt;- janitor::clean_names(wvs) glimpse(wvs) ## Rows: 69,578 ## Columns: 9 ## $ participant_id &lt;dbl&gt; 20070001, 20070002, 20070003, 20070004, 2007000… ## $ country_code &lt;chr&gt; &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;… ## $ country_name &lt;chr&gt; &quot;Andorra&quot;, &quot;Andorra&quot;, &quot;Andorra&quot;, &quot;Andorra&quot;, &quot;An… ## $ gender &lt;dbl&gt; 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0,… ## $ year_of_birth &lt;dbl&gt; 1958, 1971, 1969, 1956, 1969, 1967, 1985, 1963,… ## $ age &lt;dbl&gt; 60, 47, 48, 62, 49, 51, 33, 55, 40, 38, 54, 39,… ## $ relationship_status &lt;chr&gt; &quot;married&quot;, &quot;living together as married&quot;, &quot;separ… ## $ freedom_of_choice &lt;dbl&gt; 10, 9, 9, 9, 8, 10, 10, 8, 8, 10, 9, 8, 10, 7, … ## $ satisfaction_with_life &lt;dbl&gt; 10, 9, 9, 8, 7, 10, 5, 8, 8, 10, 8, 8, 10, 7, 1… Now that janitor has done its magic, we suddenly have easy to read variable names that are consistent with the ‘Tidyverse style guide’ (Wickham 2021). If, for whatever reason, the variable names are still not looking the way you want, you can use the function rename() from the dplyr package. wvs &lt;- wvs %&gt;% rename(satisfaction = satisfaction_with_life) glimpse(wvs) ## Rows: 69,578 ## Columns: 9 ## $ participant_id &lt;dbl&gt; 20070001, 20070002, 20070003, 20070004, 20070005, … ## $ country_code &lt;chr&gt; &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;, &quot;… ## $ country_name &lt;chr&gt; &quot;Andorra&quot;, &quot;Andorra&quot;, &quot;Andorra&quot;, &quot;Andorra&quot;, &quot;Andor… ## $ gender &lt;dbl&gt; 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0,… ## $ year_of_birth &lt;dbl&gt; 1958, 1971, 1969, 1956, 1969, 1967, 1985, 1963, 19… ## $ age &lt;dbl&gt; 60, 47, 48, 62, 49, 51, 33, 55, 40, 38, 54, 39, 44… ## $ relationship_status &lt;chr&gt; &quot;married&quot;, &quot;living together as married&quot;, &quot;separate… ## $ freedom_of_choice &lt;dbl&gt; 10, 9, 9, 9, 8, 10, 10, 8, 8, 10, 9, 8, 10, 7, 10,… ## $ satisfaction &lt;dbl&gt; 10, 9, 9, 8, 7, 10, 5, 8, 8, 10, 8, 8, 10, 7, 10, … You are probably wondering what %&gt;% stands for. This symbol is called a ‘piping operator’ and it allows us to chain multiple functions together by considering the output of the previous function. So, do not confuse &lt;- with %&gt;%. Each operator serves a different purpose. The %&gt;% has become synonymous with the tidyverse approach to R programming and is the chosen approach for this book. Many functions from the tidyverse are designed to be chained together. If we wanted to spell out what we just did we could say: wvs &lt;-: We assigned whatever happened to the right of the assign operator to the object wvs. wvs %&gt;%: We defined the dataset we want to use with the functions defined after the %&gt;%. rename(satisfaction = satisfcation_with_life): We define a new name satisfaction for the column satisfaction_with_life. Notice that the order is new_name = old_name. Here we also use =. A rare occasion where it makes sense to do so. Just for clarification, the following two lines of code accomplish the same task. The only difference lies that with %&gt;% we could chain another function right after it. You could say, it is a matter of taste which approach you prefer. However, in later chapters it will become obvious why using %&gt;% is very advantageous. # Renaming a column using &#39;%&gt;%&#39; wvs %&gt;% rename(satisfaction_new = satisfaction) ## # A tibble: 69,578 × 9 ## participant_id country_code country_name gender year_of_birth age ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20070001 AND Andorra 1 1958 60 ## 2 20070002 AND Andorra 0 1971 47 ## 3 20070003 AND Andorra 0 1969 48 ## 4 20070004 AND Andorra 1 1956 62 ## 5 20070005 AND Andorra 0 1969 49 ## 6 20070006 AND Andorra 1 1967 51 ## 7 20070007 AND Andorra 1 1985 33 ## 8 20070008 AND Andorra 0 1963 55 ## 9 20070009 AND Andorra 1 1978 40 ## 10 20070010 AND Andorra 1 1979 38 ## # … with 69,568 more rows, and 3 more variables: relationship_status &lt;chr&gt;, ## # freedom_of_choice &lt;dbl&gt;, satisfaction_new &lt;dbl&gt; # Renaming a column without &#39;%&gt;%&#39; rename(wvs, satisfaction_new = satisfaction) ## # A tibble: 69,578 × 9 ## participant_id country_code country_name gender year_of_birth age ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 20070001 AND Andorra 1 1958 60 ## 2 20070002 AND Andorra 0 1971 47 ## 3 20070003 AND Andorra 0 1969 48 ## 4 20070004 AND Andorra 1 1956 62 ## 5 20070005 AND Andorra 0 1969 49 ## 6 20070006 AND Andorra 1 1967 51 ## 7 20070007 AND Andorra 1 1985 33 ## 8 20070008 AND Andorra 0 1963 55 ## 9 20070009 AND Andorra 1 1978 40 ## 10 20070010 AND Andorra 1 1979 38 ## # … with 69,568 more rows, and 3 more variables: relationship_status &lt;chr&gt;, ## # freedom_of_choice &lt;dbl&gt;, satisfaction_new &lt;dbl&gt; Since you will be using the pipe operator very frequently, it is a good idea to remember the keyboard shortcut for it: Ctrl+Shift+M for PC and Cmd+Shift+M for Mac. 7.4 Data types: What are they and how can you change them When we inspected our data, I mentioned that some of the variables do not have the correct data type. You might be familiar with different data types by classifying them as: Nominal data, which is categorical data of no particular order, Ordinal data, which is categorical data with a defined order, and Quantitative data, which is data that usually is represented by numeric values. In R we have a slightly different distinction: character / &lt;chr&gt;: Textual data, for example the text of a tweet. factor / &lt;fct&gt;: Categorical data with a finite number of categories with no particular order. ordered / &lt;ord&gt;: Categorical data with a finite number of categories with a particular order. double / &lt;dbl&gt;: Numerical data with decimal places. integer / &lt;int&gt;: Numerical data with whole numbers only (i.e. no decimals). logical / &lt;lgl&gt;: Logical data, which only consists of values ‘TRUE’ and ‘FALSE.’ date / date: Data which consists dates, e.g. ‘2021-08-05.’ date-time / dttm: Data which consists dates and times, e.g. ‘2021-08-05 16:29:25 BST.’ For a complete list of data types I recommend to take a look at ‘Column Data Types’ (Müller and Wickham 2021). It is obvious that R has a more fine-grained categorisation of data types. The most important distinction, though, lies between &lt;chr&gt;, &lt;fct&gt;/&lt;ord&gt; and &lt;dbl&gt; for most datasets in the Social Sciences. Still, it is good to be aware of what the abbreviations in your tibble mean and how they might affect your analysis. Now that we have a solid understanding of different data types, we can have a look at our dataset and see whether readr classified our variables correctly. glimpse(wvs) ## Rows: 69,578 ## Columns: 9 ## $ participant_id &lt;dbl&gt; 20070001, 20070002, 20070003, 20070004, 20070005, … ## $ country_code &lt;chr&gt; &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;, &quot;AND&quot;, &quot;… ## $ country_name &lt;chr&gt; &quot;Andorra&quot;, &quot;Andorra&quot;, &quot;Andorra&quot;, &quot;Andorra&quot;, &quot;Andor… ## $ gender &lt;dbl&gt; 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0,… ## $ year_of_birth &lt;dbl&gt; 1958, 1971, 1969, 1956, 1969, 1967, 1985, 1963, 19… ## $ age &lt;dbl&gt; 60, 47, 48, 62, 49, 51, 33, 55, 40, 38, 54, 39, 44… ## $ relationship_status &lt;chr&gt; &quot;married&quot;, &quot;living together as married&quot;, &quot;separate… ## $ freedom_of_choice &lt;dbl&gt; 10, 9, 9, 9, 8, 10, 10, 8, 8, 10, 9, 8, 10, 7, 10,… ## $ satisfaction &lt;dbl&gt; 10, 9, 9, 8, 7, 10, 5, 8, 8, 10, 8, 8, 10, 7, 10, … readr did a great job in identifying all the numeric variables. However, by default, readr imports all variables that include text as &lt;chr&gt;. It appears, in our dataset this is not quite correct. The variables country_code, countr_name, gender and relationship_status specify a finite number of categories. Therefore they should be classified as factor. The variable participant_id is represented by numbers, but its meaning is also rather categorical in nature. We would not use the ID numbers of participants to perform additions or multiplications. This would simply make no sense. Therefore, it might be wise to turn them into a factor as well, even though we likely will not use it in our analysis and would make no difference. However, I am a stickler for those kind of things, so I would include in it. In order to perform the conversion we need to use two new functions from dplyr: mutate(): Changes, i.e. ‘mutates,’ a variable. as_factor(): Converts data from one type into a factor. If we want to convert all variables in one go, we can put them all into the same function, separated by a ,. wvs &lt;- wvs %&gt;% mutate(country_code = as_factor(country_code), country_name = as_factor(country_name), gender = as_factor(gender), relationship_status = as_factor(relationship_status), participant_id = as_factor(participant_id) ) glimpse(wvs) ## Rows: 69,578 ## Columns: 9 ## $ participant_id &lt;fct&gt; 20070001, 20070002, 20070003, 20070004, 20070005, … ## $ country_code &lt;fct&gt; AND, AND, AND, AND, AND, AND, AND, AND, AND, AND, … ## $ country_name &lt;fct&gt; &quot;Andorra&quot;, &quot;Andorra&quot;, &quot;Andorra&quot;, &quot;Andorra&quot;, &quot;Andor… ## $ gender &lt;fct&gt; 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0,… ## $ year_of_birth &lt;dbl&gt; 1958, 1971, 1969, 1956, 1969, 1967, 1985, 1963, 19… ## $ age &lt;dbl&gt; 60, 47, 48, 62, 49, 51, 33, 55, 40, 38, 54, 39, 44… ## $ relationship_status &lt;fct&gt; married, living together as married, separated, li… ## $ freedom_of_choice &lt;dbl&gt; 10, 9, 9, 9, 8, 10, 10, 8, 8, 10, 9, 8, 10, 7, 10,… ## $ satisfaction &lt;dbl&gt; 10, 9, 9, 8, 7, 10, 5, 8, 8, 10, 8, 8, 10, 7, 10, … The output in the console shows that we successfully performed the transformation and our data types are as we intended them to be. Mission accomplished. 7.5 Recoding factors (e.g. gender coded as 0 and 1) Another common problem we have to tackle when working with data is their representation in the dataset. For example, gender could be measured as male and female1 or as 0 and 1. R does not mind which way you represent your data, but some other software does. Therefore, when we import data from somewhere else the values of a variable might not look the way we want. The practicality of having your data represented accurately as what they are becomes obvious when you intend to create tables and plots. For example, we might be interested to know how many participants in the wvs were male and how many were female. The function count() from dplyr does exactly that. wvs %&gt;% count(gender) ## # A tibble: 3 × 2 ## gender n ## &lt;fct&gt; &lt;int&gt; ## 1 0 33049 ## 2 1 36478 ## 3 &lt;NA&gt; 51 Now we know how many people were male and female and how many did not disclose their gender. Or do we? The issue here is that you would have to know what the 0 and 1 stand for. Surely you would have a coding manual that gives you the answer, but it seems a bit of a complication. For gender, this might still be easy to remember, but can you recall the numbers for 48 countries? It certainly would be easier to replace the 0s and 1s with their corresponding labels. This can be achieved with a simple function called fct_recode() from forcats. Since we ‘mutate’ a variable into something else, we have to use the mutate() function too. wvs &lt;- wvs %&gt;% mutate(gender = fct_recode(gender, &quot;male&quot; = &quot;0&quot;, &quot;female&quot; = &quot;1&quot;)) If you have been following along very carefully you might spot one oddity in this code: \"0\" and \"1\". You likely recall that in Chapter 5 I mentioned that we use \"\" for character values but not for numbers. What happens if we run the code and remove \"\". wvs %&gt;% mutate(gender = fct_recode(gender, &quot;male&quot; = 0, &quot;female&quot; = 1)) ## Error: Problem with `mutate()` column `gender`. ## ℹ `gender = fct_recode(gender, male = 0, female = 1)`. ## x Each input to fct_recode must be a single named string. Problems at positions: 1, 2 The error message is very easy to understand: fct_recode() only expects strings as input and not numbers. R recognises 0 and 1 as numbers, but fct_recode() converts a factor value into another factor value. To refer to a factor level (i.e. one of the categories in our factor), we have to use \"\". In other words, data types matter and are often a source of problems with your code. Thus, always pay close attention to it. If we rerun our analysis from before and generate a frequency table for gender, we now get a much more readable output. wvs %&gt;% count(gender) ## # A tibble: 3 × 2 ## gender n ## &lt;fct&gt; &lt;int&gt; ## 1 male 33049 ## 2 female 36478 ## 3 &lt;NA&gt; 51 Another benefit of going through the trouble of recoding your factors is the readability of your plots. We could easily generate a bar plot based on the above table and have appropriate labels, instead of 0 and 1. wvs %&gt;% count(gender) %&gt;% ggplot(aes(gender, n)) + geom_col() Plots are an excellent way to explore your data and understand relationships between variables. More about this when we start to perform analytical steps on our data (see Chapter 8 and beyond). 7.6 Dealing with missing data There is hardly any Social Sciences project where researchers do not have to deal with data that is missing. Participants are sometimes not willing to complete a questionnaire or miss a second round of data collection entirely, e.g in longitudinal studies. It is not the purpose of this chapter to delve into all aspects of analysing missing data, but provide a solid starting point. There are mainly three steps involved in dealing with missing data: Mapping missing data Identifying patterns of missing data Replacing or removing missing data 7.6.1 Mapping missing data Every study that intends to be rigorous will have to first identify how much data is missing. In R this can be achieved in multiple ways, but using a specialised package like naniar does help us to do this very quickly and systematically. First we have to load the naniar package and then we use the function vis_miss() to visualise how much and where exactly data is missing. library(naniar) vis_miss(wvs) naniar plays along nicely with the tidyverse approach of programming. As such, it would also be possible to write wvs %&gt;% vis_miss(). As we can see, 99,7% of our dataset is complete and we are only missing 0.3%. The dark lines (actually blocks) refer to missing data points. On the x-axis we can see all our variables and on the y-axis we see our observations. This is the same layout as our rectangular dataset: Rows are observations and columns are variables. Overall, this dataset appears relatively complete (luckily). When working with larger datasets it might be useful to rank variables by their degree of missing data to see where the biggest problems lie. gg_miss_var(wvs) Figure 7.1: Missing data per variable It is very noticeable that freedom_of_choice has the most missing data points. If you prefer to see the actual numbers instead, we can use as series of functions that start with miss_ (for a complete list of all functions see the reference page of naniar) In order to retrieve the numeric values which are reflected in the plot above, we can write the following: # Summarise the missingness in each variable miss_var_summary(wvs) ## # A tibble: 9 × 3 ## variable n_miss pct_miss ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 freedom_of_choice 547 0.786 ## 2 relationship_status 335 0.481 ## 3 year_of_birth 328 0.471 ## 4 age 318 0.457 ## 5 satisfaction 239 0.343 ## 6 gender 51 0.0733 ## 7 participant_id 0 0 ## 8 country_code 0 0 ## 9 country_name 0 0 For mapping missing data, especially in larger datasets with many variables, I tend to prefer data visualisations over numerical results. This also has the benefit that patterns of missing data can be easily identified as well. 7.6.2 Identifying patterns of missing data If you find that your data ‘suffers’ from missing data, it is essential to answer another question: Is data missing systematically? This is quite an important diagnostic step since systematically missing data would imply that if we remove these observations from our dataset as is, we likely produce wrong results. We can distinguish missing data based on how it is missing, i.e. missing completely at random, missing at random, and missing not at random. (Rubin 1976) Missing completely at random (MCAR) means that neither observed nor missing data can systematically explain why data is missing. We can assume that data is missing not because of certain variables or conditions in our dataset. Missing at random (MAR) refers to a situation where the missing data can only be explained by the observed data, but not the missing data. Dong and Peng (2013) (p. 2) provide a good example when this is the case: Let’s suppose that students who scored low on the pre-test are more likely to drop out of the course, hence, their scores on the post-test are missing. If we assume that the probability of missing the post-test depends only on scores on the pre-test, then the missing mechanism on the post-test is MAR. In other words, for students who have the same pre-test score, the probability of their missing the post-test is random. Lastly, missing not at random (MNAR) simply implies that data is missing systematically and that other variables or reasons exist that explain why data is missing. In questionnaire-based research an easily overlooked reason that can explain missing data is the ‘page-drop-off’ phenomenon. In such cases, participants stop completing a questionnaire once they advance to another page. Figure 7.2 shows this very clearly for a large scale project where an online questionnaire was used. After almost every page break in the questionnaire, some participants decided to discontinue. Finding these types of patterns is difficult when only working with numeric values. Thus, it is always advisable to visualise your data as well. Figure 7.2: MNAR pattern in a dataset due to ‘page-drop-offs’ Understanding patterns of missing data also means we have to look at whether there are relationships between missing values, for example the co-occurrence of missing values across different variables. This can be achieved by using upset plots. An upset plot consists of three parts: Set size, intersection size and a venn diagram which defines the intersection. gg_miss_upset(wvs) In our dataset, the most frequent combination of missing data occures when only freedom_of_choice is missing (the first column), but nothing else. The next frequent combination of missing data is defined by a combination of two variables: age and year_of_birth. In total 296 participants had age and year_of_birth missing but nothing else. The set size shown in the upset plot refers to the number of missing values for each variable in the diagram. This correspondents to what we have found out when looking at Figure 7.1). 7.6.3 Replacing or removing missing data 7.7 Latent constructs and their reliability 7.7.1 Theory 7.7.2 Visualisation 7.7.3 Computation References "]]
